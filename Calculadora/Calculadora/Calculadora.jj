/* Calculadora.java */
/* Generated By:JavaCC: Do not edit this line. Calculadora.java */
package Cientifica;
// Paquete y librerías necesarias
import java.io.*;
import java.util.*;


public class Calculadora implements CalculadoraConstants {

    public static void main(String[] args) throws ParseException {

                // generateTitleASCIIArt("Math Scientific Calc");
                titulo();

                generateTitleASCIIArt("Instrucciones de uso:");

                print("1. Ingrese una expresi\u00c3\u00b3n matem\u00c3\u00a1tica en la l\u00c3\u00adnea de comandos.");
                print("2. Presione Enter para evaluar la expresi\u00c3\u00b3n.");
                print("3. El resultado de la evaluaci\u00c3\u00b3n se mostrar\u00c3\u00a1 en la pantalla.");
                print("");
                generateTitleASCIIArt("Ejemplos de uso:");
                print("Aritm\u00c3\u00a9ticas");
                print("* 2 + 2    = 4");
                print("* 5 - 3    = 2");
                print("* 4 * 3    = 12");
                print("* 10 / 2   = 5");

                print("");
                print("Trigonom\u00c3\u00a9tricas");
                print("* log(10)  = 1");
                print("* sin(90)  = 1");
                print("* cos(180) = -1");
                print("* tan(45)  = 0.9");
                print("");


        Scanner entradaEscaner = new Scanner(System.in);
                Calculadora parser = new Calculadora(new StringReader(""));

                while (true) { // Ciclo infinito

                generateTitleASCIIArt("Ingrese una expresi\u00c3\u00b3n: ");
                String calculo = entradaEscaner.nextLine();
                        parser.ReInit(new StringReader(calculo));

                // Intenta parsear la expresión y manejar la excepción ParseException
                try {

                double result = parser.Expression();

                        // Redondear valores muy pequeños a cero
                    if (Math.abs(result) < 1e-10) result = 0.0;

                                // Imprimir el resultado con dos decimales o sin decimales (si es entero)
                    String formattedResult = String.format("%.2f", result); // Formatear con dos decimales
                    if (formattedResult.indexOf('.') == -1) { // Si no hay punto decimal, eliminar los ceros decimales
                        formattedResult = formattedResult.replace(",00", "");
                    }

                    System.out.println("Resultado: " + formattedResult);

                } catch (TokenMgrError e) {
                            System.err.println("Error l\u00c3\u00a9xico: " + e.getMessage());
                        } catch (ParseException e) {
                            System.err.println("Error sint\u00c3\u00a1ctico: " + e.getMessage());
                        }catch (Exception e) {
                                System.err.println("Error general: " + e.getMessage());
                        }
                        // Limpiar la pantalla (opcional)
                System.out.print("\033[H\033[2J"); // Limpia la pantalla en la mayoría de terminales

                System.out.print("\u00c2\u00bfDesea ingresar otra expresi\u00c3\u00b3n? (s/n): ");
                String continuar = entradaEscaner.nextLine();

                if (!continuar.equalsIgnoreCase("s")) {
                    break; // Salir del bucle si no se ingresa "s"
                }
            }
    }


    public static double sin(double x) {
        System.out.println("Ingres\u00c3\u00b3 el operador: sin");
        return Math.sin(Math.toRadians(x)); // Convertir grados a radianes para función sin
    }

    public static double cos(double x) {
        System.out.println("Ingres\u00c3\u00b3 el operador: cos");

        return Math.cos(Math.toRadians(x)); // Convertir grados a radianes para función cos
    }

    public static double tan(double x) {
        System.out.println("Ingres\u00c3\u00b3 el operador: tan");

        return Math.tan(Math.toRadians(x)); // Convertir grados a radianes para función tan
    }


        public static void print(String x) {
        System.out.println(x);
    }

    public static void generateTitleASCIIArt(String title) {
        int titleLength = title.length();
        int borderLength = titleLength + 4;

        StringBuilder asciiArt = new StringBuilder();

        // Top border
        asciiArt.append("+" + "-".repeat(borderLength - 2) + "+").append("\n");

        // Title line
        asciiArt.append("| " + title + " ".repeat(borderLength - titleLength - 3) + "|").append("\n");

        // Bottom border
        asciiArt.append("+" + "-".repeat(borderLength - 2) + "+").append("\n");

        System.out.println(asciiArt.toString());
    }


        public static void titulo() {
        System.out.println("   _____          __  .__        _________      .__               __  .__  ____._         _________        .__          ");
        System.out.println("  /     \\ _____ /  ||  |__    /   ____/ ____ || ____   _____/  ||/ ____|| ____   \\   ___ \\_____  |  |   ____  ");
        System.out.println(" /  \\ /  \\\\__  \\\\   _|  |  \\   \\____  \\/ ___\\|  _/ __ \\ /    \\   __|  \\   __\\|  _/ ___\\  /    \\  \\/\\_  \\ |  | _/ ___\\ ");
        System.out.println("/    Y    \\/ __ \\|  | |   Y  \\  /        \\  \\|  \\  ___/|   |  |  | |  ||  |  |  \\  \\__  \\     \\/ __ \\|  |\\  \\__ ");
        System.out.println("\\|__  (____  || ||  / /______  /\\___  ||\\___  ||  || ||||  ||\\__  >  \\______  (____  |/\\___  >");
        System.out.println("        \\/     \\/          \\/          \\/     \\/        \\/     \\/                       \\/          \\/      \\/         \\/ ");
    }

        // Método para calcular log 
        public static double log(double value) {
        System.out.println("Ingres\u00c3\u00b3 el operador: log");

                double base = 10;
        if (base <= 0 || base == 1) {
                throw new IllegalArgumentException("Invalid base for logarithm");
            }
        return Math.log(value) / Math.log(base);
        }

// Método para la expresión (principal)
  static final public double Expression() throws ParseException {double result, term;
    Token t;
    result = Term();
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:
      case MINUS:{
        ;
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:{
        t = jj_consume_token(PLUS);
        break;
        }
      case MINUS:{
        t = jj_consume_token(MINUS);
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      term = Term();
// Coincide con un signo (+ o -) seguido de un término
            if (t.kind == PLUS) {
                System.out.println("Ingres\u00c3\u00b3 el operador: +");

               result += term;
                }
            else {
                System.out.println("Ingres\u00c3\u00b3 el operador: -");

               result -= term;
             }          // Si es -, resta el término

    }
{if ("" != null) return result;}
    throw new Error("Missing return statement in function");
}

// Método para el término
  static final public double Term() throws ParseException {double result, factor;
    Token t;
    result = Factor();
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MULT:
      case DIV:{
        ;
        break;
        }
      default:
        jj_la1[2] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MULT:{
        t = jj_consume_token(MULT);
        break;
        }
      case DIV:{
        t = jj_consume_token(DIV);
        break;
        }
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      factor = Factor();
// Coincide con un operador (* o /) seguido de un factor
            if (t.kind == MULT) {                System.out.println("Ingres\u00c3\u00b3 el operador: *");
               result *= factor;}// Si es *, multiplica por el factor
            else {
                 System.out.println("Ingres\u00c3\u00b3 el operador: /");
                                // Si es /
                // Manejo de división por cero
                if (factor == 0) {
                    {if (true) throw new ArithmeticException("Error: Divisi\u00c3\u00b3n por cero");}
                } else {
                    result /= factor;
                }
            }
    }
{if ("" != null) return result;}
    throw new Error("Missing return statement in function");
}

// Método para el factor
  static final public double Factor() throws ParseException {Token t;
    double result;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NUMBER:{
      // Manejo de números
          t = jj_consume_token(NUMBER);
System.out.println("Ingres\u00c3\u00b3 el n\u00c3\u00bamero: " + t.image);
      {if ("" != null) return Double.parseDouble(t.image);}
      break;
      }
    case LPAREN:{
      jj_consume_token(LPAREN);
      result = Expression();
      jj_consume_token(RPAREN);
{if ("" != null) return result;}
      break;
      }
    case SIN:{
      jj_consume_token(SIN);
      jj_consume_token(LPAREN);
      result = Expression();
      jj_consume_token(RPAREN);
{if ("" != null) return Calculadora.sin(result);}
      break;
      }
    case COS:{
      jj_consume_token(COS);
      jj_consume_token(LPAREN);
      result = Expression();
      jj_consume_token(RPAREN);
{if ("" != null) return Calculadora.cos(result);}
      break;
      }
    case TAN:{
      jj_consume_token(TAN);
      jj_consume_token(LPAREN);
      result = Expression();
      jj_consume_token(RPAREN);
// Verificación de argumento válido para la tangente (evitar tangente de 90 grados)
        if (Math.abs(result - Math.PI / 2) < 1e-10) {
            {if (true) throw new ArithmeticException("Error: Tangente indefinida (\u00c3\u00a1ngulo cercano a 90 grados)");}
        } else {
            {if ("" != null) return Calculadora.tan(result);}
        }
      break;
      }
    case LOG:{
      jj_consume_token(LOG);
      jj_consume_token(LPAREN);
      result = Expression();
      jj_consume_token(RPAREN);
{if ("" != null) return Calculadora.log(result);}
      break;
      }
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public CalculadoraTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[5];
  static private int[] jj_la1_0;
  static {
	   jj_la1_init_0();
	}
	private static void jj_la1_init_0() {
	   jj_la1_0 = new int[] {0x60,0x60,0x180,0x180,0x47a00,};
	}

  /** Constructor with InputStream. */
  public Calculadora(java.io.InputStream stream) {
	  this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Calculadora(java.io.InputStream stream, String encoding) {
	 if (jj_initialized_once) {
	   System.out.println("ERROR: Second call to constructor of static parser.  ");
	   System.out.println("	   You must either use ReInit() or set the JavaCC option STATIC to false");
	   System.out.println("	   during parser generation.");
	   throw new Error();
	 }
	 jj_initialized_once = true;
	 try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source = new CalculadoraTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
	  ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Calculadora(java.io.Reader stream) {
	 if (jj_initialized_once) {
	   System.out.println("ERROR: Second call to constructor of static parser. ");
	   System.out.println("	   You must either use ReInit() or set the JavaCC option STATIC to false");
	   System.out.println("	   during parser generation.");
	   throw new Error();
	 }
	 jj_initialized_once = true;
	 jj_input_stream = new SimpleCharStream(stream, 1, 1);
	 token_source = new CalculadoraTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
	if (jj_input_stream == null) {
	   jj_input_stream = new SimpleCharStream(stream, 1, 1);
	} else {
	   jj_input_stream.ReInit(stream, 1, 1);
	}
	if (token_source == null) {
 token_source = new CalculadoraTokenManager(jj_input_stream);
	}

	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Calculadora(CalculadoraTokenManager tm) {
	 if (jj_initialized_once) {
	   System.out.println("ERROR: Second call to constructor of static parser. ");
	   System.out.println("	   You must either use ReInit() or set the JavaCC option STATIC to false");
	   System.out.println("	   during parser generation.");
	   throw new Error();
	 }
	 jj_initialized_once = true;
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(CalculadoraTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
	 Token oldToken;
	 if ((oldToken = token).next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 if (token.kind == kind) {
	   jj_gen++;
	   return token;
	 }
	 token = oldToken;
	 jj_kind = kind;
	 throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
	 if (token.next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 jj_gen++;
	 return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
	 Token t = token;
	 for (int i = 0; i < index; i++) {
	   if (t.next != null) t = t.next;
	   else t = t.next = token_source.getNextToken();
	 }
	 return t;
  }

  static private int jj_ntk_f() {
	 if ((jj_nt=token.next) == null)
	   return (jj_ntk = (token.next=token_source.getNextToken()).kind);
	 else
	   return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
	 jj_expentries.clear();
	 boolean[] la1tokens = new boolean[19];
	 if (jj_kind >= 0) {
	   la1tokens[jj_kind] = true;
	   jj_kind = -1;
	 }
	 for (int i = 0; i < 5; i++) {
	   if (jj_la1[i] == jj_gen) {
		 for (int j = 0; j < 32; j++) {
		   if ((jj_la1_0[i] & (1<<j)) != 0) {
			 la1tokens[j] = true;
		   }
		 }
	   }
	 }
	 for (int i = 0; i < 19; i++) {
	   if (la1tokens[i]) {
		 jj_expentry = new int[1];
		 jj_expentry[0] = i;
		 jj_expentries.add(jj_expentry);
	   }
	 }
	 int[][] exptokseq = new int[jj_expentries.size()][];
	 for (int i = 0; i < jj_expentries.size(); i++) {
	   exptokseq[i] = jj_expentries.get(i);
	 }
	 return new ParseException(token, exptokseq, tokenImage);
  }

  static private boolean trace_enabled;

/** Trace enabled. */
  static final public boolean trace_enabled() {
	 return trace_enabled;
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}

// Ignorar espacios, tabuladores, saltos de línea y retorno de carro